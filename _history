{"entries":[{"timestamp":1753843822741,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":15445,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":26,"diffs":[[1,"    \"name\": \"ChatGOT\",\n"]]},{"start1":206,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1753843885581,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]}]},{"timestamp":1754435537413,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":209,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1753843822740,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ChatGOT\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1754435537413,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"// built in constant event ID\nconst _KEYBOARD_CHANGE_EVENT = 7339\nconst _KEYBOARD_ENTER_EVENT = 7340\nconst _KEYBOARD_CANCEL_EVENT = 7341\n// Constants and helper arrays\nconst PADDING = 4;\nconst NUM_LETTERS = 26;\nconst ALPHABET_ROW_LENGTH = 12;\nconst NUM_ROWS = Math.ceil(NUM_LETTERS / ALPHABET_ROW_LENGTH);\nconst INPUT_ROWS = 2;\n\nconst CONTENT_WIDTH = screen.width - PADDING * 2;\nconst CONTENT_HEIGHT = screen.height - PADDING * 2;\nconst CONTENT_TOP = PADDING;\n\nconst CELL_WIDTH = Math.floor(CONTENT_WIDTH / ALPHABET_ROW_LENGTH);\nconst CELL_HEIGHT = CELL_WIDTH;\nconst LETTER_OFFSET_X = Math.floor((CELL_WIDTH - image.font8.charWidth) / 2);\nconst LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - image.font8.charHeight) / 2);\nconst BLANK_PADDING = 1;\nconst ROW_LEFT = PADDING + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * ALPHABET_ROW_LENGTH)) / 2);\n\nconst BOTTOM_BAR_ALPHABET_MARGIN = 4;\nconst BOTTOM_BAR_HEIGHT = PADDING + BOTTOM_BAR_ALPHABET_MARGIN + CELL_HEIGHT;\nconst BOTTOM_BAR_BUTTON_WIDTH = PADDING * 2 + image.font8.charWidth * 3;\nconst BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - image.font8.charHeight) / 2;\nconst BOTTOM_BAR_SHIFT_X = (BOTTOM_BAR_BUTTON_WIDTH - image.font8.charWidth * 3) / 2;\nconst BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - image.font8.charWidth * 2) / 2;\nconst CONFIRM_BUTTON_LEFT = screen.width - BOTTOM_BAR_BUTTON_WIDTH;\n\nconst ALPHABET_HEIGHT = NUM_ROWS * CELL_HEIGHT;\nconst ALPHABET_TOP = CONTENT_TOP + CONTENT_HEIGHT - ALPHABET_HEIGHT - BOTTOM_BAR_HEIGHT;\nconst ALPHABET_INPUT_MARGIN = 10;\n\nconst INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\nconst INPUT_TOP = ALPHABET_TOP - INPUT_HEIGHT - ALPHABET_INPUT_MARGIN;\n\nconst lowerShiftText = \"ABC\";\nconst upperShiftText = \"abc\";\n\nconst digitsUpper = [\" \", \",\", \".\", \"?\", \"!\", \":\", \";\", \"\\\"\", \"(\", \")\"];\nconst confirmText = \"OK\";\n\n// Helper function to map index to character\nfunction getCharForIndex(index: number, upper: boolean) {\n    if (index < 26) {\n        return String.fromCharCode(index + (upper ? 65 : 97));\n    } else {\n        if (upper) {\n            return digitsUpper[index - 26];\n        } else {\n            return \"\" + (index - 26);\n        }\n    }\n}\n\n// Prompt class definition\nclass Prompt {\n    theme: PromptTheme;\n\n    message: string;\n    answerLength: number;\n    result: string;\n\n    protected confirmPressed: boolean;\n    protected cursorRow: number;\n    protected cursorColumn: number;\n    protected upper: boolean;\n    protected useSystemKeyboard: boolean;\n\n    protected renderable: scene.Renderable;\n    protected selectionStart: number;\n    protected selectionEnd: number;\n\n    protected keyboardRows: number;\n    protected keyboardColumns: number;\n\n    private changeTime = 0;\n\n    constructor(theme?: PromptTheme) {\n        if (theme) {\n            this.theme = theme;\n        }\n        else {\n            this.theme = {\n                colorPrompt: 1,\n                colorInput: 3,\n                colorInputHighlighted: 5,\n                colorInputText: 1,\n                colorAlphabet: 1,\n                colorCursor: 7,\n                colorBackground: 15,\n                colorBottomBackground: 3,\n                colorBottomText: 1,\n            };\n        }\n        this.cursorRow = 0;\n        this.cursorColumn = 0;\n        this.upper = false;\n        this.result = \"\";\n        this.keyboardColumns = ALPHABET_ROW_LENGTH;\n        this.keyboardRows = NUM_ROWS;\n        this.selectionStart = 0;\n        this.selectionEnd = 0;\n    }\n\n    show(message: string, answerLength: number, useOnScreenKeyboard = false) {\n        this.message = message;\n        this.answerLength = answerLength;\n\n        controller._setUserEventsEnabled(false);\n        game.pushScene()\n\n        this.createRenderable();\n        this.confirmPressed = false;\n\n        if (!useOnScreenKeyboard && control.deviceDalVersion() === \"sim\" && helpers._isSystemKeyboardSupported()) {\n            this.useSystemKeyboard = true;\n            helpers._promptForText(this.answerLength, this.numbersOnly());\n            this.selectionEnd = 0;\n            this.selectionStart = 0;\n            control.onEvent(_KEYBOARD_CHANGE_EVENT, 0, () => {\n                this.result = helpers._getTextPromptString().substr(0, this.answerLength);\n\n                this.changeTime = game.runtime();\n\n                this.selectionStart = helpers._getTextPromptSelectionStart();\n                this.selectionEnd = helpers._getTextPromptSelectionEnd();\n            })\n\n            let cancelled = false;\n            let finished = false;\n\n            control.onEvent(_KEYBOARD_CANCEL_EVENT, 0, () => {\n                cancelled = true;\n            });\n\n            control.onEvent(_KEYBOARD_ENTER_EVENT, 0, () => {\n                finished = true;\n            });\n\n            pauseUntil(() => cancelled || finished);\n\n            if (cancelled) {\n                this.useSystemKeyboard = false;\n                this.selectionStart = this.result.length;\n                this.selectionEnd = this.selectionStart;\n                this.registerHandlers();\n                pauseUntil(() => this.confirmPressed);\n            }\n        }\n        else {\n            this.useSystemKeyboard = false;\n            this.registerHandlers();\n            pauseUntil(() => this.confirmPressed);\n        }\n\n        game.popScene();\n        controller._setUserEventsEnabled(true);\n\n        return this.result;\n    }\n\n    protected numbersOnly() {\n        return false;\n    }\n\n    protected createRenderable() {\n        if (this.renderable) {\n            this.renderable.destroy();\n        }\n\n        const promptText = new sprites.RenderText(this.message, CONTENT_WIDTH);\n        let systemKeyboardText: sprites.RenderText;\n\n        this.renderable = scene.createRenderable(-1, () => {\n            promptText.draw(screen, (screen.width >> 1) - (promptText.width >> 1), CONTENT_TOP, this.theme.colorPrompt, 0, 2)\n            this.drawInputArea();\n\n            if (!this.useSystemKeyboard) {\n                this.drawKeyboard();\n                this.drawBottomBar();\n                return;\n            }\n\n            if (!systemKeyboardText) {\n                systemKeyboardText = new sprites.RenderText(helpers._getLocalizedInstructions(), CONTENT_WIDTH);\n            }\n\n            screen.fillRect(0, screen.height - (PADDING << 1) - systemKeyboardText.height, screen.width, screen.height, this.theme.colorBottomBackground);\n            systemKeyboardText.draw(screen, PADDING, screen.height - PADDING - systemKeyboardText.height, this.theme.colorBottomText);\n        });\n    }\n\n    protected drawInputArea() {\n        const answerLeft = ROW_LEFT + Math.floor(\n            ((CELL_WIDTH * ALPHABET_ROW_LENGTH) -\n                CELL_WIDTH * Math.min(this.answerLength, ALPHABET_ROW_LENGTH)) / 2);\n\n        for (let i = 0; i < this.answerLength; i++) {\n            const col = i % ALPHABET_ROW_LENGTH;\n            const row = Math.floor(i / ALPHABET_ROW_LENGTH);\n\n            if (this.selectionStart !== this.selectionEnd && i >= this.selectionStart && i < this.selectionEnd) {\n                screen.fillRect(\n                    answerLeft + col * CELL_WIDTH,\n                    INPUT_TOP + row * CELL_HEIGHT,\n                    CELL_WIDTH,\n                    CELL_HEIGHT,\n                    this.theme.colorCursor\n                );\n            }\n\n            screen.fillRect(\n                answerLeft + col * CELL_WIDTH + BLANK_PADDING,\n                INPUT_TOP + row * CELL_HEIGHT + CELL_HEIGHT - 1,\n                CELL_WIDTH - BLANK_PADDING * 2,\n                1,\n                !this.useSystemKeyboard && !this.blink() && i === this.selectionStart ? this.theme.colorInputHighlighted : this.theme.colorInput\n            );\n\n            if (i < this.result.length) {\n                const char = this.result.charAt(i);\n                screen.print(\n                    char,\n                    answerLeft + col * CELL_WIDTH + LETTER_OFFSET_X,\n                    INPUT_TOP + row * CELL_HEIGHT + LETTER_OFFSET_Y,\n                    this.theme.colorInputText,\n                    image.font8\n                );\n            }\n        }\n\n        if (this.useSystemKeyboard) {\n            if (this.selectionStart === this.selectionEnd && this.selectionStart < this.answerLength) {\n                const col = this.selectionStart % ALPHABET_ROW_LENGTH;\n                const row = Math.floor(this.selectionStart / ALPHABET_ROW_LENGTH);\n                if (!this.blink()) {\n                    screen.fillRect(\n                        answerLeft + col * CELL_WIDTH,\n                        INPUT_TOP + row * CELL_HEIGHT,\n                        1,\n                        CELL_HEIGHT,\n                        this.theme.colorCursor\n                    );\n                }\n            }\n        }\n    }\n\n    protected drawKeyboard() {\n        const top = screen.height - BOTTOM_BAR_HEIGHT - this.keyboardRows * CELL_HEIGHT - PADDING;\n        const left = (screen.width >> 1) - ((CELL_WIDTH * this.keyboardColumns) >> 1)\n        for (let j = 0; j < this.keyboardRows * this.keyboardColumns; j++) {\n            const col = j % this.keyboardColumns;\n            const row = Math.idiv(j, this.keyboardColumns);\n\n            if (col === this.cursorColumn && row === this.cursorRow) {\n                screen.fillRect(\n                    left + col * CELL_WIDTH,\n                    top + row * CELL_HEIGHT,\n                    CELL_WIDTH,\n                    CELL_HEIGHT,\n                    this.theme.colorCursor\n                )\n            }\n\n            screen.print(\n                this.getSymbolForIndex(j),\n                left + col * CELL_WIDTH + LETTER_OFFSET_X,\n                top + row * CELL_HEIGHT + LETTER_OFFSET_Y,\n                this.theme.colorAlphabet\n            )\n        }\n    }\n\n    protected drawBottomBar() {\n        this.drawBottomBarBackground();\n        this.drawShift(this.cursorRow === 3 && !(this.cursorColumn & 1));\n        this.drawConfirm(this.cursorRow === 3 && !!(this.cursorColumn & 1));\n    }\n\n    protected drawBottomBarBackground() {\n        screen.fillRect(0, screen.height - BOTTOM_BAR_HEIGHT, screen.width, BOTTOM_BAR_HEIGHT, this.theme.colorBottomBackground);\n    }\n\n    protected drawShift(highlighted: boolean) {\n        if (highlighted) {\n            screen.fillRect(\n                0,\n                screen.height - BOTTOM_BAR_HEIGHT,\n                BOTTOM_BAR_BUTTON_WIDTH,\n                BOTTOM_BAR_HEIGHT,\n                this.theme.colorCursor\n            );\n        }\n\n        let shiftText = lowerShiftText;\n        if (this.upper) {\n            shiftText = upperShiftText;\n        }\n        screen.print(\n            shiftText,\n            BOTTOM_BAR_SHIFT_X,\n            screen.height - BOTTOM_BAR_HEIGHT + BOTTOM_BAR_TEXT_Y,\n            this.theme.colorBottomText\n        )\n    }\n\n    protected drawConfirm(highlighted: boolean) {\n        if (highlighted) {\n            screen.fillRect(\n                CONFIRM_BUTTON_LEFT,\n                screen.height - BOTTOM_BAR_HEIGHT,\n                BOTTOM_BAR_BUTTON_WIDTH,\n                BOTTOM_BAR_HEIGHT,\n                this.theme.colorCursor\n            );\n        }\n\n        screen.print(\n            confirmText,\n            CONFIRM_BUTTON_LEFT + BOTTOM_BAR_CONFIRM_X,\n            screen.height - BOTTOM_BAR_HEIGHT + BOTTOM_BAR_TEXT_Y,\n            this.theme.colorBottomText\n        )\n    }\n\n    protected getSymbolForIndex(index: number) {\n        return getCharForIndex(index, this.upper);\n    }\n\n    private registerHandlers() {\n        controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.moveVertical(true);\n        })\n\n        controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.moveVertical(false);\n        })\n\n        controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.moveHorizontal(true);\n        });\n\n        controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.moveHorizontal(false);\n        });\n\n        controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.confirm();\n        });\n\n        controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n            this.delete();\n        });\n    }\n\n    protected moveVertical(up: boolean) {\n        if (up) {\n            if (this.cursorRow === this.keyboardRows) {\n                this.cursorRow = this.keyboardRows - 1;\n\n                if (this.cursorColumn % 2) {\n                    this.cursorColumn = this.keyboardColumns - 1;\n                }\n                else {\n                    this.cursorColumn = 0;\n                }\n            }\n            else {\n                this.cursorRow = Math.max(0, this.cursorRow - 1);\n            }\n        }\n        else {\n            this.cursorRow = Math.min(this.keyboardRows, this.cursorRow + 1);\n\n            if (this.cursorRow === this.keyboardRows) {\n                // Go to closest button\n                this.cursorColumn = this.cursorColumn > 5 ? 1 : 0;\n            }\n        }\n    }\n\n    protected moveHorizontal(right: boolean) {\n        if (right) {\n            this.cursorColumn = (this.cursorColumn + 1) % this.keyboardColumns;\n        }\n        else {\n            this.cursorColumn = (this.cursorColumn + (this.keyboardColumns - 1)) % this.keyboardColumns;\n        }\n    }\n\n    protected confirm() {\n        if (this.cursorRow === 3) {\n            if (this.cursorColumn % 2) {\n                this.confirmPressed = true;\n            }\n            else {\n                this.upper = !this.upper;\n            }\n        }\n        else {\n            if (this.selectionStart >= this.answerLength) return;\n\n            const index = this.cursorColumn + this.cursorRow * this.keyboardColumns\n            const letter = getCharForIndex(index, this.upper);\n\n            if (!this.result) {\n                this.result = letter;\n            }\n            else {\n                this.result += letter;\n            }\n\n            this.changeTime = game.runtime();\n\n            this.changeInputIndex(1);\n        }\n    }\n\n    protected delete() {\n        if (this.selectionStart <= 0) return;\n\n        this.result = this.result.substr(0, this.result.length - 1);\n        this.changeInputIndex(-1);\n    }\n\n    protected changeInputIndex(delta: number) {\n        this.selectionStart += delta;\n        this.selectionEnd = this.selectionStart;\n    }\n\n    protected blink() {\n        return Math.idiv(game.runtime() - this.changeTime, 500) & 1;\n    }\n}\n\n// Theme interface definition (to avoid errors)\ninterface PromptTheme {\n    colorPrompt: number;\n    colorInput: number;\n    colorInputHighlighted: number;\n    colorInputText: number;\n    colorAlphabet: number;\n    colorCursor: number;\n    colorBackground: number;\n    colorBottomBackground: number;\n    colorBottomText: number;\n}\n\n// Usage example\nconst greyTheme: PromptTheme = {\n    colorPrompt: 1, // Dark grey for the prompt message\n    colorInput: 15, // White for the input text field background\n    colorInputHighlighted: 9, // Light grey/blue for the input highlight (cursor line)\n    colorInputText: 1, // Dark grey for the input text\n    colorAlphabet: 1, // Dark grey for the alphabet characters\n    colorCursor: 9, // Light grey/blue for the keyboard cursor\n    colorBackground: 14, // A slightly darker grey for the main background\n    colorBottomBackground: 15, // White for the bottom bar background\n    colorBottomText: 1, // Dark grey for the bottom bar text\n};\n\nconst prompt = new Prompt(greyTheme);\nconst userAnswer = prompt.show(\"Enter your name:\", 10);\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ChatGOTGPT\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[{"id":"26838-75743-32975-78853","timestamp":1753843884561}],"lastSaveTime":1754435537418}